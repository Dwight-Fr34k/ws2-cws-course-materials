<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Javascript &mdash; ES2015</title>
  <meta name="author" content="Rogier van der Linde - ikdoeict.be">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="library/reveal/css/reveal.min.css">
	<link rel="stylesheet" href="library/reveal/css/theme/rogier.css" id="rogier">
	<link rel="stylesheet" href="library/highlight/styles/vs.css">
	<link rel="stylesheet" href="css/common.css">
  <style>

    .reveal ul.chapterlist {
      column-count: 2;
      column-gap: 60px;
      -moz-column-count: 2;
      -moz-column-gap: 60px;
      -webkit-column-count: 2;
      -webkit-column-gap: 60px;
      padding-left: 20px;
      padding-bottom: 30px;
      display: block;
      width: 680px;
    }

    .reveal a.canary {
      font-style: italic;
      color: #900;
      text-decoration: none;
    }

    .reveal a.canary:hover {
      color: #900;
      text-decoration: underline;
    }

  </style>
  <script>
    'use strict'
  </script>
</head>

<body>

  <!-- SLIDES -->
	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section>
				<h1>ES2015</h1>
				<small>use the arrow keys to navigate; press space for slide overview<br />
          examples will run best on <a href="https://www.google.nl/chrome/browser/canary.html" class="canary">Chrome Canary</a>
        </small>
				<figure>
					<img src="img/02_es2015/syntax.png" alt="" width="180" />
					<figcaption></figcaption>
				</figure>

				<footer>
					<a href="http://www.ikdoeict.be/">ikdoeict.be</a> &mdash; <a href="mailto:rogier.vanderlinde@odisee.be">rogier.vanderlinde@odisee.be</a>
				</footer>
			</section>

      <section>
        <section>
          <h1>ES2015</h1>
          <h2>about</h2>
          <ul class="chapterlist">
            <!-- to be filled by Javascript -->
          </ul>
        </section>
        <section>
          <h2>ECMAScript 6</h2>
          <ul>
            <li>
              A.K.A. Harmony, A.K.A. ES2015
            </li>
            <li>
              feature-frozen in August 2014
            </li>
            <li>
              after a bugfixing period, published as standard on June 17, 2015
            </li>
            <li>
              should be used in strict mode:
              <div><pre class="bigger"><code class="language-javascript">'use strict'

// rest of ES6 code here</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="ES2015">
          <h2><del>ECMAScript 6</del> ES2015</h2>
          <ul>
            <li>
              future versions will follow the <code class="hl">ES[yyyy]</code> pattern, e.g. <del>ES7</del> ES2016 (so the correct name for ES6 is ES2015)
            </li>
            <li>
              yearly release; features that don't make it in time, take the next
            </li>
            <li>
              reason: pressing browser vendors to implement features quickly
            </li>
          </ul>
        </section>
        <section data-toc-title="Using ES2015">
          <h2>Using ES2015 (1)</h2>
          <ul>
            <li>
              browser support is <a href="https://kangax.github.io/compat-table/es6/">shaky at best</a>; only the very latest A-graded browsers make a serious effort
            </li>
            <li>
              for testing purposes, <a href="https://www.google.nl/chrome/browser/canary.html">Chrome Canary</a> is your best bet
            </li>
            <li>
              your options:
              <ul>
                <li>
                  use the <a href="https://github.com/paulmillr/es6-shim">ES6 shim</a>, but
                  <ul>
                    <li>it can't shim new language syntax, only basic extensions like Array functions &mdash; bummer</li>
                    <li>it acutally <a href="https://kangax.github.io/compat-table/es6/#es6shim">only patches 17%</a> &mdash; double bummer</li>
                  </ul>
                </li>
                <li>
                  use a transpiler to translate ES6 into ES5, e.g. <a href="http://babeljs.io/">Babel</a> (incorporate in Gulp or Grunt build process with <a href="https://github.com/babel/babelify">Babalify</a>) or <a href="https://github.com/google/traceur-compiler">Traceur</a>, but
                  <ul>
                    <li>harder to debug, even with source maps</li>
                    <li>transpilers can't make performance optimizations for the browser running the code</li>
                  </ul>
                </li>
                <li>target the latest A-graded browsers only</li>
                <li>see it as an educational experiment and have fun</li>
              </ul>
            </li>
          </ul>
          <div class="tooltip">
            <div>
              Still: transpilers are here to stay. Newer ES versions will be transpiled to older ES versions, e.g. ES2017 into ES2016. So get used to having it in your development stack.
            </div>
          </div>
        </section>
        <section data-toc-title="">
          <h2>Using ES2015 (2)</h2>
          <ul>
            <li>
              you can transpile on-the-fly with Traceur:
              <div><pre class="bigger"><code class="language-html" contenteditable>&lt;!doctype html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;!-- add some linked scripts --&gt;
  &lt;script src="https://jspm.io/system@0.16.js"&gt;&lt;/script&gt;
  &lt;script src="https://google.github.io/traceur-compiler/bin/traceur.js"&gt;&lt;/script&gt;
  &lt;script src="https://google.github.io/traceur-compiler/src/bootstrap.js"&gt;&lt;/script&gt;
  &lt;!-- add type="module" to your ES2015 script --&gt;
  &lt;script type="module"&gt;
    'use strict'

    var list = [77,  true, 'hello'];
    var [a, b, c] = list; // normally unsupported in Chrome
    console.log(a); // 77

  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>
              <div class="demolink"><a href="demos/02_es2015/traceur.html">demo</a></div>
            </li>
            <li class="arrow">
              transpiling leads to poor performance; only use during development
            </li>
            <li class="arrow">
              in production: pre-transpile with Babel or Traceur
            </li>
          </ul>
        </section>
        <section data-toc-title="ES2016 playgrounds">
          <h2>ES2015 playgrounds (1)</h2>
          <ul>
            <li>
              <a href="http://www.es6fiddle.net/">ES6Fiddle</a>: nice simple online tool with pre-made examples
              <img src="img/02_es2015/es6fiddle.png" alt="" class="border" style="max-width: 90%; margin: 0 auto; display: block; margin-top: 1rem" />
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>ES2015 playgrounds (2)</h2>
          <ul>
            <li>
              <a href="http://www.codepen.io/">Codepen</a>: save and distribute your examples; Babel transpiler integrated
              <img src="img/02_es2015/codepen.png" alt="" class="border" style="max-width: 90%; margin: 0 auto; display: block; margin-top: 1rem" />
            </li>
          </ul>
        </section>
      </section>

      <section>
        <section>
          <h1>ES2015</h1>
          <h2>variables</h2>
          <ul class="chapterlist">
            <!-- to be filled by Javascript -->
          </ul>
        </section>
        <section data-toc-title="Var, Let and Const">
          <h2>Var, Let and Const (1)</h2>
          <ul>
            <li>
              <em>scope</em> means where a variable lives
            </li>
            <li>
              the scope of <code class="hl">var</code> is only limited by a function, not by blocks:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var x = 1; // x is global
for (var y = 0; y &lt; 4; y++) { // y is global
  var z = 10; // z is global
}
console.log(x) // 1
console.log(y) // 4
console.log(z) // 10
</code></pre></div>
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var x = 1; // x is global
var test = function() {
  var y = 2; // y is local
};
console.log(x); // 1
console.log(y); // error: y only lives within the function scope
</code></pre></div>

            </li>
          </ul>
          <div class="tooltip">
            <div>
              Note that the scope in Javascript differs from most other languages as C# or Java, where in the first example y would be local to the loop.
            </div>
          </div>
        </section>
        <section data-toc-title="">
          <h2>Var, Let and Const (2)</h2>
          <ul>
            <li>
              the scope of <code class="hl">let</code> is also limited by blocks:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var x = 1; // x is global
for (let y = 0; y &lt; 4; y++) { // y is local
  let z = 10; // z is local
}
console.log(x); // 1
console.log(y); // error!
console.log(z); // error!
</code></pre></div>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Var, Let and Const (3)</h2>
          <ul>
            <li>
              remember this little troublemaker called 'closures':
              <div><pre class="bigger"><code class="language-javascript wrong strict overlayrun" contenteditable>var obj = {};
// loop creating three new functions
for (var i = 0; i &lt; 3; i++) {
  obj['testFunction' + i] = function() {
    console.log(i);
  }
}

// test the functions
obj.testFunction0(); // 3!
obj.testFunction1(); // 3!
obj.testFunction2(); // 3!</code></pre></div>
            </li>
            <li class="arrow">in Javascript, <code class="hl">for() { ... }</code> doesn't define a new scope</li>
            <li class="arrow"><code class="hl">var i</code> also exists outside the loop, and keeps its final value</li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Var, Let and Const (4)</h2>
          <ul>
            <li>
              solve it with the new <code class="hl">let</code> keyword:
              <div><pre class="bigger"><code class="language-javascript right strict overlayrun" contenteditable>var obj = {};
// loop creating three new functions
for (<span style="color:#900">let</span> i = 0; i &lt; 3; i++) {
  obj['testFunction' + i] = function() {
    console.log(i);
  }
}

// test the functions
obj.testFunction0(); // 0
obj.testFunction1(); // 1
obj.testFunction2(); // 2</code></pre></div>
            </li>
            <li class="arrow"><code class="hl">let i</code> only exists inside the loop</li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Var, Let and Const (5)</h2>
          <ul>
            <li>
              Javascript finally accepts constants:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>const text = 'hello';
text = 'goodbye'; // will throw an error</code></pre></div>
            </li>
            <li>
              You can't change the value of a constant, but you can still change its properties:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>const person1 = {
  name: 'Roger',
  age: 44
};

person1.age = 45; // happy birthday</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Var, Let or Const?</h2>
          <img src="img/02_es2015/const_let_var.png" alt="" class="border" />
        </section>
        <section>
          <h2>Multiline strings</h2>
          <ul>
            <li>
              Python-inspired multiline strings; notice the backticks <code>`...`</code>:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var message = `Ik ben voor je gevallen,
gevallen op straat,
Ik zag je mooie ogen
maar de stoeprand te laat`;

console.log(message);
</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>String interpolation</h2>
          <ul>
            <li>
              remember PHP:
              <div><pre class="bigger"><code class="language-php" contenteditable>$name = "Rogier";
$message = "hello $name, how are you?" // hello Rogier, how are you?</code></pre></div>
            </li>
            <li>
              in ES6 (notice again the backticks):
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>var person1 = { name: 'Rogier', age: 44 };
var myName = 'Bob';
var message = `hello ${person1.name}, my name is ${myName}`;
console.log(message);  // hello Rogier, my name is Bob</code></pre></div>
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>var id = 3;
var language = 'nl';
var url = `http://www.somedomain.com/?id=${id}&amp;lang=${language}`;
console.log(url); // http://www.somedomain.com/?id=3&amp;lang=nl</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>Object property shorthand</h2>
          <ul>
            <li>
              ES5:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var name = 'Bobby', age = 42;
var person = {name: name, age: age};
</code></pre></div>
            </li>
            <li>
              ES6:
              <div><pre class="bigger"><code class="language-javascript overlayrun right" contenteditable>var name = 'Bobby', age = 42;
var person = {name, age};
console.log(person);
</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>Method property shorthand</h2>
          <ul>
            <li>
              ES5:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var obj = {
  sayHello: function() {
    console.log('hello');
  },
  sum: function(a, b) {
    return a + b;
  }
};
</code></pre></div>
            </li>
            <li>
              ES6:
              <div><pre class="bigger"><code class="language-javascript right strict overlayrun" contenteditable>var obj = {
  sayHello() {
    console.log('hello');
  },
  sum(a, b) {
    return a + b;
  }
};

console.log(obj.sum(6, 8)); // 14
</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>...Rest parameter</h2>
          <ul>
            <li>
              aggregate remaining parameters into a single <code class="hl">...rest</code> parameter:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var test = function(x, y, ...a) {
  return (x + y) * a.length;
}
console.log(test(1, 2, "hello", true, 7)); // 9</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="...Spread operator">
          <h2>...Spread operator (1)</h2>
          <ul>
            <li>
              spread an array or string into individual elements:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var str = "hello";
var chars = [ ...str ]; // ["h", "e", "l", "l", "o"]</code></pre></div>
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var options = ["green", true, 7];
var extendedOptions = [1, 2, ...params]; // [1, 2, "green", true, 7]</code></pre></div>
            </li>
            <li>
              example: easy array concatenation
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>var arr = [1, 2, ...[3, 4, 5], 6, 7];
console.log(arr);</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="Destructuring &ndash; arrays">
          <h2>Destructuring &ndash; arrays (1)</h2>
          <ul>
            <li>
              ES5:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var list = [77, true, 'hello'];
var a = list[0];
var b = list[1];
var c = list[2];
</code></pre></div>
            </li>
            <li>
              ES6:
              <div><pre class="bigger"><code class="language-javascript right strict overlayrun" contenteditable>var list = [77,  true, 'hello'];
var [a, b, c] = list; // array destructuring

console.log(a); // 77
console.log(b); // true
console.log(c); // 'hello'</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Destructuring &ndash; arrays (2)</h2>
          <ul>
            <li>
              default values:
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>var list = [7, 42];
var [a = 1, b = 2, c = 3, d] = list;

console.log(b); // 42
console.log(c); // 3
console.log(d); // undefined</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Destructuring &ndash; arrays (3)</h2>
          <ul>
            <li>
              skipping values:
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>var list = [77, true, 'hello'];
var [a, , c] = list;

console.log(a); // 77
console.log(c); // 'hello'</code></pre></div>
            </li>
            <li>
              easy value swapping with destructuring:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var [a, b] = [b, a];</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Destructuring &ndash; arrays (4)</h2>
          <ul>
            <li>
              return multiple values:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var func = function() {
  return [1, true, 'hello', {}]; // return multiple values
}

var [a, , b, ] = func();

console.log(a); // 1
console.log(b); // 'hello'</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="Destructuring &ndash; objects">
          <h2>Destructuring &ndash; objects (1)</h2>
          <ul>
            <li>
              Destructuring an object into variables (shorthand version):
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var test = {
  name: 'Rogier',
  address: {
    street: 'Kerkstraat',
    number: 33
  },
  age: 42
};

var { name, address } = test; // object destructuring

console.log(name); // Rogier
console.log(address); // {street: "Kerkstraat", number: 33}
console.log(address.number); // 33</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Destructuring &ndash; objects (2)</h2>
          <ul>
            <li>
              Explicit variable names &amp; deep matching:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var test = {
  name: 'Rogier',
  address: {
    street: 'Kerkstraat',
    number: 33
  },
  age: 42,
  isMale: true
};

var { name: n, address: {street: s}, age: a } = test; // object destructuring

console.log(n); // Rogier
console.log(s); // 'Kerkstraat'
console.log(a); // 42
</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>New built-in methods</h2>
          <ul>
            <li>
              some nice new methods are introduced:
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>// array
console.log([1, 3, 4, 2].find(x => x > 3)); // 4; uses arrow functions

// string
console.log("ha".repeat(3)); // hahaha
console.log("hello".startsWith("ello", 1)) // true
console.log("hello".endsWith("hell", 4)); // true
console.log("hello".includes("ell")); // true

// math
console.log(Math.trunc(42.7)) // 42
console.log(Math.sign(7)) // 1
console.log(Math.sign(0)) // 0
console.log(Math.sign(-7)) // -1
</code></pre></div>
            </li>
          </ul>
        </section>
      </section>

      <section>
        <section>
          <h1>ES2015</h1>
          <h2>functions</h2>
          <ul class="chapterlist">
            <!-- to be filled by Javascript -->
          </ul>
        </section>
        <section>
          <h2>Arrow functions</h2>
          <ul>
            <li>
              shorthand notation for functions (like C# lambda expressions)
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>// no parameters
var sayHello = () => console.log('hello');
sayHello(); // hello </code></pre></div>
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>// single parameter
var double = a => a * 2;
console.log(double(4)); // 8</code></pre></div>
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>// multiple parameters
var sum = (a, b) => a + b;
console.log(sum(2,4)); // 6</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>Default parameters</h2>
          <ul>
            <li>
              ES5:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>function f (x, y, z) {
  if (y === undefined) y = 7;
  if (z === undefined) z = 42;
  return x + y + z;
};
</code></pre></div>
            </li>
            <li>
              ES6:
              <div><pre class="bigger"><code class="language-javascript right" contenteditable>function f (x, y = 7, z = 42) {
  return x + y + z;
}</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="Generator functions">
          <h2>Generator functions (1)</h2>
          <ul>
            <li>
              a generator is a function that can return multiple values
            </li>
            <li>
              each time next() is called, it runs till the next <code>yield</code> and pauses:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// define a generator
var someGenerator = function*(){
  yield 'hello';
  yield 9;
  yield true;
}

// calling the generator returns an iterator object
var gen = someGenerator();

// call the next iterator value
console.log(gen.next().value); // 'hello'
console.log(gen.next().value); // 9
console.log(gen.next().value); // true
console.log(gen.next().value); // undefined
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Generator functions (2)</h2>
          <ul>
            <li>
              <code>next()</code> actually returns an object with <code>value</code> and <code>done</code> props:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var someGenerator = function*(){
  yield 'an';
  yield 'bob';
}

var gen = someGenerator();

console.log(gen.next()); // {value: "an", done: false}
console.log(gen.next()); // {value: "bob", done: false}
console.log(gen.next()); // {value: undefined, done: true}
</code></pre></div>
            </li>
          </ul>
          <div class="tooltip">
            <div>
              simply said: generators calculate a set of <code>yield</code>s, which are called one by one by <code>next()</code>
            </div>
          </div>
        </section>
        <section data-toc-title="">
          <h2>Generator functions (3)</h2>
          <ul>
            <li>
              example with parameters:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var counterGenerator = function*(start, step){
  var number = start;
  while(true) {
    yield number;
    number += step;
  }
}

var gen = counterGenerator(100, 3);

console.log(gen.next().value); // 100
console.log(gen.next().value); // 103
console.log(gen.next().value); // 106
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Generator functions (4)</h2>
          <ul>
            <li>
              fibonacci example:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>function* fibonacci(n) {
  const infinite = !n &amp;&amp; n !== 0;
  let current = 0;
  let next = 1;

  while (infinite || n--) {
    yield current;
    [current, next] = [next, current + next];
  }
}

// oldskool:
var fibGenerator = fibonacci();
console.log(fibGenerator.next().value); // 0
console.log(fibGenerator.next().value); // 1
console.log(fibGenerator.next().value); // 1

// generators are iterables, so for...of work, as do spreads:
let [...first10] = fibonacci(10);
console.log(first10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Generator functions (5)</h2>
          <ul>
            <li>
              you can delegate to another generator with <code>yield*</code>:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>function* g1() {
  yield 2;
  yield 3;
  yield 4;
}

function* g2() {
  yield 1;
  yield* g1();
  yield 5;
}

var iterator = g2();

var next = iterator.next();
while(!next.done) {
  console.log(next.value); // 1 2 3 4 5
  next = iterator.next();
}</code></pre></div>
            </li>
            <li class="arrow">
              more in-depth lecture on <a href="https://ponyfoo.com/articles/es6-generators-in-depth">ponyfoo.com</a>
            </li>            
          </ul>
        </section>
      </section>

      <section>
        <section>
          <h1>ES2015</h1>
          <h2>collections</h2>
          <ul class="chapterlist">
            <!-- to be filled by Javascript -->
          </ul>
        </section>
        <section data-toc-title="for...of">
          <h2>for...of (1)</h2>
          <ul>
            <li>
              Iterates arrays over values instead of over keys:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var arr = ['hello', 111];

var obj = { a: 'bye', b: 222 };

for (let i in arr) {
  if (!arr.hasOwnProperty(i)) continue;
  console.log(i); // 0 1
}

for (let i of arr) {
  console.log(i); // hello 111
}

for (let i in obj) {
  if (!obj.hasOwnProperty(i)) continue;
  console.log(i); // a b
}

// for (let i of obj) { error! by default, object is not iterable
//   console.log(i);
// }

for (let i in obj) {
  console.log(obj[i]); // bye 222
}</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>for...of (2)</h2>
          <ul>
            <li>
              Sidenote: when looping arrays or objects with <code>for...in</code>, you should use <code>hasOwnProperty()</code> to skip properties inherited from the prototype. Try this fragment:
              <div><pre class="bigger"><code class="language-javascript overlayrun wrong" contenteditable>// define prototype method
Array.prototype.containsValue = function(obj) {
  for (var key in this)
    if (this[key] == obj) return true;
  return false;
}

// create array and loop over properties
var arr = new Array();
arr['one'] = 1;
arr['two'] = 2;
arr['three'] = 3;
for(var i in arr) {
//  if (!arr.hasOwnProperty(i)) continue;
  console.log(i);
}</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>Sets</h2>
          <ul>
            <li>
              Like arrays, but without double values:
              <div><pre class="bigger"><code class="language-javascript overlayrun strict" contenteditable>let x = new Set([1, 2, 3, 4, 4, 4, 5]);

x.add(6);
x.delete(2);

console.log('The set contains', x.size, 'elements.');
console.log('The set has 1:', x.has(1));
console.log('The set has 8:', x.has(8));

// iteration
for (let value of x) {
  console.log(value);
}</code></pre></div>
            </li>
            <li class="arrow">
              other methods are <code>clear()</code>, <code>forEach()</code>, <code>values()</code>
            </li>
          </ul>
          <div class="tooltip">
            <div>
              Think of sets like a collection of values which have already been chosen. E.g. try building a hangman game with sets.
            </div>
          </div>
        </section>
        <section>
          <h2>Maps</h2>
          <ul>
            <li>
              Little bit like objects, but anything can be key:
              <div><pre class="bigger"><code class="language-javascript overlayrun strict" contenteditable>let x = new Map([
  [new Date(), function today () {}],
  [y => y * 2, { pony: 'foo' }],
  ['items', [1, 2]]
]);

x.delete('items');
x.set('author', 'Rogier');

// iteration
for (let [key, value] of x) {
  console.log(`${key}: ${value}`);
}</code></pre></div>
            </li>
            <li class="arrow">
              other methods are <code>clear()</code>, <code>forEach()</code>, <code>values()</code>, <code>keys()</code>
            </li>
          </ul>
        </section>
        <section data-toc-title="WeakSet and WeakMap">
          <h2>WeakSet and WeakMap (1)</h2>
          <ul>
            <li>
              Same as Set and Map, but with some limitations:
              <ul>
                <li>you can only add objects (weakset) or use objects as keys (weakmap)</li>
                <li>you can't use iteration, so no <code>size</code>, <code>for...in</code> etc...</li>
              </ul>
            </li>
            <li>
              Main advantage: entry is automatically removed by garbage collector when no more references exist
              <div><pre class="bigger"><code class="language-javascript overlayrun strict" contenteditable>var set = new Set();
var weakset = new WeakSet();

(function(){
  var a = {x: 12};
  var b = {y: 12};

  set.add(a);
  weakset.add(b);
})(); // a and b only exist within function

console.log(set); // map will contain a until you remove it manually
console.log(weakset); // weakmap will contain b until garbage collected
</code></pre></div>
            </li>
          </ul>
          <div class="tooltip">
            <div>
              You will probably still see b in weakset; the reason is that garbage collection only happens now and then, whenever the browser feels the time is right. Alas, there is no way to force a GC.
            </div>
          </div>
        </section>
        <section data-toc-title="">
          <h2>WeakSet and WeakMap (2)</h2>
          <ul>
            <li>
              Use weak collections instead of Map and Set whenever you can to prevent memory leaks
            </li>
            <li>
              Typical use cases:
              <ul>
                <li>organise objects in groups (WeakSet)</li>
                <li>keep track of which objects already have been processed (WeakSet)</li>
                <li>extend objects without interfering with garbage collection (WeakMap)</li>
              </ul>
            </li>
            <li>
              Weak collections are about GC, so it doesn't make sense to add object literals:
              <div><pre class="bigger"><code class="language-javascript wrong" contenteditable>var weakmap = new WeakMap();
weakmap.set(new Date(), 111); // doesn't make sense
weakmap.set({}, 222); // doesn't make sense</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="Iterators">
          <h2>Iterators (1)</h2>
          <ul>
            <li>
              An <em>iterator</em> defines how an object is iterated with <code>for...in...</code>
            </li>
            <li>
              It is accessed as the evaluated property [Symbol.iterator]
            </li>
            <li>
              It returns a value <code class="hl">{value: ..., done: ...}</code>
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>var foo = {};

foo[Symbol.iterator] = function() {
  let items = ['alice', 'bob', 'clive', 'dave'];
  return {
    next: function () {
      return {
        done: items.length === 0,
        value: items.shift()
      }
    }
  }
};

for (let item of foo) {
  console.log(item); // alice bob clive dave
}</code></pre></div>
            </li>
          </ul>
          <div class="tooltip">
            <div>
              <code class="hl">Symbol</code> is a new primitive type introduced in ES2015. They look an awful lot like Strings, except for a few differences; they are unique, for example. Symbols are mainly used for iterators and a little funky, so we won't get into them. If you wish, you can read all about them on <a href="https://ponyfoo.com/articles/es6-symbols-in-depth">ponyfoo.com</a>.
            </div>
          </div>
        </section>
        <section data-toc-title="">
          <h2>Iterators (1)</h2>
          <ul>
            <li>
              Shorter syntax:
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>var foo = {
  [Symbol.iterator]: () => ({
    items: ['alice', 'bob', 'clive', 'dave'],
    next: function () {
      return {
        done: this.items.length === 0,
        value: this.items.shift()
      }
    }
  })
};

for (let item of foo) {
  console.log(item); // alice bob clive dave
}</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Iterators (1)</h2>
          <ul>
            <li>
              Chipping off another 5 characters:
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>var foo = {};

foo[Symbol.iterator]() {
  return {
    items: ['alice', 'bob', 'clive', 'dave'],
    next: function () {
      return {
        done: this.items.length === 0,
        value: this.items.shift()
      }
    }
  }
};

for (let item of foo) {
  console.log(item); // alice bob clive dave
}</code></pre></div>
            </li>
          </ul>
        </section>

        <section data-toc-title="">
          <h2>Iterators (2)</h2>
          <ul>
            <li>
              A fibonacci example:
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>let fibonacci = {
  [Symbol.iterator]() {
    let pre = 0, cur = 1;
    return {
      next () {
        [pre, cur] = [cur, pre + cur];
        return { done: false, value: cur };
      }
    };
  }
};

for (let n of fibonacci) {
  if (n > 1000) break;
  console.log(n);
};</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Iterators (3)</h2>
          <ul>
            <li>
              An example using priorities:
              <div><pre class="bigger"><code class="language-javascript overlayrun" contenteditable>var custom_collection = {
  elements: [
    {val: 111, priority: 1},
    {val: 222, priority: 2},
    {val: 333, priority: 1},
    {val: 444, priority: 3},
    {val: 555, priority: 2}
  ],
  [Symbol.iterator]: function() {
    var e = this.elements;
    var setDone = new WeakSet();
    var numReturned = 0;
    return {
      next: function() {
        if (numReturned == e.length) {
          return { value: undefined, done: true };
        }
        let prior = -1;
        let retval = undefined;
        for (let elem of e) {
          if (setDone.has(elem)) continue;
          if (elem.priority > prior) {
            prior = elem.priority;
            retval = elem;
          }
        }
        numReturned++;
        setDone.add(retval);
        return { value: retval.val, done: false };
      },
    };
  }
}

for(var i of custom_collection) {
  console.log(i); // 444 222 555 111 333
};
</code></pre></div>
            </li>
          </ul>
        </section>
      </section>

      <section>
        <section>
          <h1>ES2015</h1>
          <h2>OO concepts</h2>
          <ul class="chapterlist">
            <!-- to be filled by Javascript -->
          </ul>
        </section>
        <section data-toc-title="Class definitions">
          <h2>Class definitions (1)</h2>
          <ul>
            <li>
              ES5:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var Shape = function (id, x, y) {
  this.id = id;
  this.move(x, y) = function (x, y) {
    this.x = x;
    this.y = y;
  };
};</code></pre></div>
            </li>
            <li>
              ES6:
              <div><pre class="bigger"><code class="language-javascript right overlayrun" contenteditable>class Shape {
  constructor (id, x, y) {
    this.id = id;
    this.move(x, y);
  }
  move (x, y) {
    this.x = x;
    this.y = y;
  }
};

var dot1 = new Shape('dot 1', 25, 50);
console.log(`shape ${dot1.id} has position (${dot1.x},${dot1.y})`);</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Class definitions (2)</h2>
          <ul>
            <li>
              Static class members:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>class Rectangle {
  ...
  static defaultRectangle () {
    return new Rectangle("default", 0, 0, 100, 100)
  }
}
var defRectangle = Rectangle.defaultRectangle();</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="Inheritance">
          <h2>Inheritance (1)</h2>
          <ul>
            <li>
              ES5:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>var Rectangle = function (id, x, y, width, height) {
  Shape.call(this, id, x, y);
  this.width  = width;
  this.height = height;
};
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;
var Circle = function (id, x, y, radius) {
  Shape.call(this, id, x, y);
  this.radius = radius;
};
Circle.prototype = Object.create(Shape.prototype);
Circle.prototype.constructor = Circle;</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Inheritance (2)</h2>
          <ul>
            <li>
              ES6:
              <div><pre class="bigger"><code class="language-javascript right" contenteditable>class Rectangle extends Shape {
  constructor (id, x, y, width, height) {
    super(id, x, y);
    this.width  = width;
    this.height = height;
  }
}
class Circle extends Shape {
  constructor (id, x, y, radius) {
    super(id, x, y);
    this.radius = radius;
  }
}</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="Modules">
          <h2>Modules (1)</h2>
          <ul>
            <li>
              In ES5, you need namespaces to group functionality
              <div><pre class="bigger"><code class="language-javascript" contenteditable>// libs/SomeLibrary/SomeApi.js
SomeLibrary = SomeLibrary || {};
SomeLibrary.SomeApi = {};
SomeLibrary.SomeApi.function1 = function () { ... };
SomeLibrary.SomeApi.function2 = function () { ... };
SomeLibrary.SomeApi.var1 = ...;
SomeLibrary.SomeApi.var2 = ...;

// use in someApp.js
var api = SomeLibrary.SomeApi; // use shortcut if you like
console.log(api.function2(...));

// use in otherApp.js
var api = SomeLibrary.SomeApi; // use shortcut if you like
console.log(api.function1(...));
console.log(api.var2);
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Modules (2)</h2>
          <ul>
            <li>
              Proposed syntax in ES6:
              <div><pre class="bigger"><code class="language-javascript" contenteditable>// libs/SomeLibrary/SomeApi.js
export function1 = function () { ... };
export function2 = function () { ... };
export var var1 = ...;
export var var2 = ...;

// use in someApp.js
import * as api from "libs/SomeLibrary/SomeApi"
console.log(api.function2(...));

// use in otherApp.js
import {function1 as f1, var2 as v2} from "libs/SomeLibrary/SomeApi"
console.log(f1(...));
console.log(v2);
</code></pre></div>
            </li>
            <li class="arrow">
               no more namespace pollution
            </li>
            <li class="arrow">
              full syntax see <a href="https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Statements/import">developer.mozilla.org</a>
            </li>
          </ul>
        </section>
      </section>

      <section>
        <section>
          <h1>ES2015</h1>
          <h2>internationalization</h2>
          <ul class="chapterlist">
            <!-- to be filled by Javascript -->
          </ul>
        </section>
        <section>
          <h2>Collation</h2>
          <ul>
            <li>
              <em>Collation</em> means sorting order, which differs from country to country:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// in German,  "ä" sorts with "a"
// in Swedish, "ä" sorts after "z"
var list = [ "ä", "a", "z" ];
var beCollator = new Intl.Collator("be");
var svCollator = new Intl.Collator("sv");
console.log(beCollator.compare("ä", "z")); // -1;
console.log(svCollator.compare("ä", "z")); // 1;
console.log(list.sort(beCollator.compare)) // [ "a", "ä", "z" ];
console.log(list.sort(svCollator.compare)) // [ "a", "z", "ä" ];</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>Number formatting</h2>
          <ul>
            <li>
              Localize number formatting:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var beNumberFormat = new Intl.NumberFormat("nl-BE");
var enNumberFormat = new Intl.NumberFormat("en-US");

console.log(beNumberFormat.format(1234567.89)); // 1.234.567,89
console.log(enNumberFormat.format(1234567.89)); // 1,234,567.89
</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>Currency formatting</h2>
          <ul>
            <li>
              Localize currency formatting:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var usNumberFormat = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" });
var gbNumberFormat = new Intl.NumberFormat("en-GB", { style: "currency", currency: "GBP" });
var beNumberFormat = new Intl.NumberFormat("nl-BE", { style: "currency", currency: "EUR" });
console.log(usNumberFormat.format(100200300.40)); // $100,200,300.40
console.log(gbNumberFormat.format(100200300.40)); // £100,200,300.40
console.log(beNumberFormat.format(100200300.40)); // 100.200.300,40 €
</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>DateTime formatting</h2>
          <ul>
            <li>
              Localize date/time formatting:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var beDateTimeFormat = new Intl.DateTimeFormat("de-DE");
var usDateTimeFormat = new Intl.DateTimeFormat("en-US");
console.log(beDateTimeFormat.format(new Date("2015-01-02"))); // 2.1.2015
console.log(usDateTimeFormat.format(new Date("2015-01-02"))); // 1/2/2015</code></pre></div>
            </li>
          </ul>
        </section>
      </section>

      <section>
        <section>
          <h1>ES2015</h1>
          <h2>proxies</h2>
          <ul class="chapterlist">
            <!-- to be filled by Javascript -->
          </ul>
        </section>
        <section data-toc-title="proxies">
          <h2>proxy (1)</h2>
          <ul>
            <li>
              proxies allow to attach behaviour whenever an object's properties are accessed
            </li>
            <li>
              in its simplest form, it is just a passthrough:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var handler = {}
var target = {}
var proxy = new Proxy(target, handler)
proxy.a = 'Alice' // property set
proxy.b = 'Bob' // property set
console.log(proxy.a); // property get
console.log(proxy.b); // property get
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>proxy (2)</h2>
          <ul>
            <li>
              with some behaviour attached to <code>get</code> and <code>set</code>:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var handler = {
  // proxy trap for 'get'
  get (target, key) {
    console.info(`Get on property ${key}`);
    return target[key];
  },
  // proxy trap for 'set'
  set (target, key, value) {
    console.info(`Set on property ${key}`);
    target[key] = value;
    return true;
  }
};
var target = {};
var proxy = new Proxy(target, handler)
proxy.a = 'Alice'; // property set
proxy.b = 'Bob'; // property set
console.log(proxy.a); // property get
console.log(proxy.b); // property get
</code></pre></div>
            </li>
            <li class="arrow">
              full list of possible traps on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">developer.mozilla.org</a>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>proxy (3)</h2>
          <ul>
            <li>
              proxies allow access control, e.g. make all '_'-prefixed private:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var handler = {
  get (target, key) {
    if (key[0] === '_') throw new Error(`Invalid attempt to get private "${key}" property`);
    console.info(`Get on property ${key}`);
    return target[key];
  },
  set (target, key, value) {
    if (key[0] === '_') throw new Error(`Invalid attempt to set private "${key}" property`);
    console.info(`Set on property ${key}`);
    return true;
  }
};
var target = {};
var proxy = new Proxy(target, handler);
proxy.a = 'Alice';
proxy.b = 'Bob';
proxy._c = 'Clive';
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>proxy (4)</h2>
          <ul>
            <li>
              proxies may also be used for validation schemes:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var handler = {
  set (target, key, value) {
    if (key == 'age' &amp;&amp; value &lt; 0) throw new Error(`age cannot be negative`);
    return true;
  }
};
var person = {};
var proxy = new Proxy(person, handler);
proxy.age = -1; // throws an error
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>proxy (5)</h2>
          <ul>
            <li>
              note that you can still access properties directly:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var handler = {
  set (target, key, value) {
    if (key == 'age' &amp;&amp; value &lt; 0) throw new Error(`age cannot be negative`);
    return true;
  }
};
var person = {};
var proxy = new Proxy(person, handler);
person.age = -1; // no problem
</code></pre></div>
            </li>
          </ul>
        </section>
      </section>

      <section>
        <section>
          <h1>ES2015</h1>
          <h2>promises</h2>
          <ul class="chapterlist">
            <!-- to be filled by Javascript -->
          </ul>
        </section>
        <section>
          <h2>promises</h2>
          <ul>
            <li>
              Solves problems with classic async solutions based on nested callback functions (<code>onSucces</code>, <code>onError</code>):
              <ul class="x-style">
                <li>deeper and deeper nesting ('callback hell')</li>
                <li>difficult error management</li>
                <li>not very intuitive (nothing is returned)</li>
              </ul>
            </li>
            <li>
              Concept of promises was <a href="https://dojotoolkit.org/reference-guide/1.10/dojo/Deferred.html">introduced by DoJo in 2007</a>
            </li>
            <li>
              Promises are cool, I promise...
            </li>
          </ul>
        </section>
        <section data-toc-title="basic promise">
          <h2>basic promise (1)</h2>
          <blockquote style="width: 95%; font-size: smaller">
            [daughter] &mdash; "I promise to clean my room today"<br>
            [mom] &mdash; "Ok. If you do, I'll give you a candy. But if you don't, I'll tell dad about it."
          </blockquote>
          <ul>
            <li>
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// daughter's promise
let cleanRoom = new Promise(function (resolve, reject) {
  if (Math.random() > 0.5) resolve(); // 50% chance that promise is kept
  else reject();
})

// mom's reactions
cleanRoom
  .then(function() { console.log('well done — here is your candy') })
  .catch(function() { console.log('boo — I\'ll have to tell dad') });
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>basic promise (2)</h2>
          <ul>
            <li>
              same but with cleaner arrow notations:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// daughter's promise
let cleanRoom = new Promise(function (resolve, reject) {
  if (Math.random() > 0.5) resolve(); // 50% chance that promise is kept
  else reject();
})

// mom's reactions
cleanRoom
  .then(() => console.log('well done — here is your candy'))
  .catch(() => console.log('boo — I\'ll have to tell dad'));
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>basic promise (3)</h2>
          <ul>
            <li>
              same but with <code class="hl">.then(result => {...}, error => {...})</code> notation:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// daughter's promise
let cleanRoom = new Promise(function (resolve, reject) {
  if (Math.random() > 0.5) resolve(); // 50% chance that promise is kept
  else reject();
})

// mom's reactions
cleanRoom.then(
  () => console.log('well done — here is your candy'),
  () => console.log('boo — I\'ll have to tell dad')
);
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>basic promise (4)</h2>
          <ul>
            <li>
              a promise, once made, can be kept ('resolved') or failed ('rejected')
            </li>
            <li>
              a possible fail <i>must</i> be caught:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun wrong" contenteditable>let promise1 = new Promise(function (resolve, reject) {
  reject();
});

// correct: promise1.catch(() => {});
</code></pre></div>
            </li>
            <li>
              shorter notation for previous example:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun wrong" contenteditable>Promise.reject();
// correct: Promise.reject().catch(() => console.log('promise rejected'));
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>basic promise (5)</h2>
          <ul>
            <li>
              a promise can be pending, or resolved / rejected (= settled)
            </li>
            <li>
              a promise can only settle once:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>let promise = new Promise(function (resolve, reject) {
  console.log('pending');
  let delay = 6000; // change to 2000 and run again
  setTimeout(resolve, delay);
  setTimeout(reject, 3000);
});

promise
  .then(() => console.log('settled (resolved)'))
  .catch(() => console.log('settled (rejected)'));</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>passing data</h2>
          <blockquote style="width: 95%; font-size: smaller">
            [daughter] &mdash; "I promise to clean my room today"<br>
            [mom] &mdash; "Ok. If you do, you can pick a candy. If not, I want to hear your excuse."
          </blockquote>
          <ul>
            <li>
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// daughter's promise
let cleanRoom = new Promise(function (resolve, reject) {
  // 50% chance that promise is kept
  if (Math.random() > 0.5) resolve('chocolate bar');
  else reject('fell asleep');
})

// mom's reactions
cleanRoom
  .then(result => console.log('well done — here is your ' + result))
  .catch(error => console.log('boo — you ' + error));
</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>multiple branches</h2>
          <blockquote style="width: 95%; font-size: smaller">
            [daughter] &mdash; "I promise to clean my room today"<br>
            [mom] &mdash; "Ok. If you do, I'll give you a candy. If you don't, I won't care."<br>
            [dad] &mdash; "If you don't, I'll spank you."
          </blockquote>
          <ul>
            <li>
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// daughter's promise
let cleanRoom = new Promise(function (resolve, reject) {
  if (Math.random() > 0.5) resolve(); // 50% chance that promise is kept
  else reject();
})

// mom's reactions
cleanRoom
  .then(() => console.log('well done — here is your candy'))
  .catch(() => {});

// dad's reactions
cleanRoom.catch(error => console.log('Here is your spanking'));
</code></pre></div>
            </li>
            <li class="arrow">
              a branch should finish with <code>catch</code> to prevent uncaught errors
            </li>
          </ul>
        </section>
        <section data-toc-title="chaining promises">
          <h2>chaining promises (1)</h2>
          <blockquote style="width: 95%; font-size: smaller">
            [dad] &mdash; "I promise to fix the car today"<br>
            [mom] &mdash; "good, because I promised we would take the kids to the park."<br>
            [big brother] &mdash; "little brother, i will ask mom if we go to the park"
          </blockquote>
          <ul>
            <li>
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// dad's promise
var fixCar = new Promise(function (resolve, reject) {
  // 50% chance dad fixes the car
  if (Math.random() > 0.5) resolve('it was the carburator');
  else reject('dad didn\'t find the problem');
});

// mom's promise
var goToPark = new Promise(function (resolve, reject) {
  // 25% chance mom's got a headache
  if (Math.random() > 0.75) {
    reject('mom has a headache');
    fixCar.catch(() => {}); // it doesn't matter if the car gets fixed or not
  }
  // depends on whether dad gets the car fixed or not
  else fixCar.then(res => resolve(res), err => reject(err));
});

// big brother's promise
var tellLittleBrother = new Promise(function (resolve, reject) {
  goToPark.then(
    res => {
      resolve({msg: 'ok, we can go, ' + res, success: true});
    },
    err => {
      resolve({msg: 'sorry bro\', we cannot go, ' + err, success: false});
    })
});

// little brother's reaction
tellLittleBrother.then(
  res => {
    console.log('[big brother] ' + res.msg);
    if(res.success) {
      console.log('[little brother] yippeee!');
    } else {
      console.log('[little brother] wèèèh!');
    }
  }
); // no need to catch here; big brother always keeps his promise</code></pre></div>
            </li>
            <li class="arrow">
              a branch should finish with <code>catch</code> to prevent uncaught errors
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>chaining promises (2)</h2>
          <ul>
            <li>
              with extra messages and more realistic with delays:
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>var fixCar = new Promise(function (resolve, reject) {
  console.log('---- dad starts fixing the car');
  // 50% chance dad fixes the car
  setTimeout(
    Math.random() > 0.5 ?
      () => {
        console.log('---- dad found the problem');
        resolve('it was the carburator')
      } : () => {
        console.log('---- dad gives up');
        reject('dad didn\'t find the problem')
      },
    2000
  );
});

// mom's promise
var goToPark = new Promise(function (resolve, reject) {
  // 25% chance mom's got a headache
  if (Math.random() > 0.75) {
    console.log('---- mom starts developing a headache');
    setTimeout(() => reject('mom has a headache'), 300);
    fixCar.catch(() => {}); // it doesn't matter if the car gets fixed or not
  }
  // depends on whether dad gets the car fixed or not
  else {
    fixCar.then(
      res => {
        console.log('---- mom notifies big brother');
        setTimeout(() => resolve(res), 1000)
      },
      err => {
        console.log('---- mom notifies big brother');
        setTimeout(() => reject(err), 1000)
      }
    );
  }
});

// big brother's promise
var tellLittleBrother = new Promise(function (resolve, reject) {
  goToPark.then(
    res => {
      console.log('---- big brother runs to little brother with a smile');
      setTimeout(() => {
        resolve({msg: 'ok, we can go, ' + res, success: true});
      }, 1000)
    },
    err => {
      console.log('---- big brother runs to little brother with a frown');
      setTimeout(() => {
        resolve({msg: 'sorry bro\', we cannot go, ' + err, success: false});
      }, 1000)
    }
  )
});

// little brother's reaction
tellLittleBrother.then(
  res => {
    console.log('[big brother] ' + res.msg);
    if(res.success) {
      console.log('[little brother] yippeee!');
    } else {
      console.log('[little brother] wèèèh!');
    }
  }
); // no need to catch here; big brother always keeps his promise
</code></pre></div>
            </li>
            <li class="arrow">
              with classic nested callback functions you'd have lots of nesting!
            </li>
          </ul>
        </section>
        <section>
          <h2>promise.all</h2>
          <blockquote style="width: 95%; font-size: smaller">
            [kids] &mdash; "Can we go to the park today?"<br>
            [mom] &mdash; "Only if you both clean your rooms"
          </blockquote>
          <ul>
            <li>
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// kid1 promise
let cleanRoom1 = new Promise(function (resolve, reject) {
  if (Math.random() > 0.5) resolve(); // 50% chance that promise is kept
  else reject('kid 1 failed');
})

// kid2 promise
let cleanRoom2 = new Promise(function (resolve, reject) {
  if (Math.random() > 0.5) resolve(); // 50% chance that promise is kept
  else reject('kid 2 failed');
})

// all promises must be resolved:
Promise.all([
  cleanRoom1,
  cleanRoom2
]).then(() => console.log('well done, we go')).catch(err => console.log(err));
</code></pre></div>
            </li>
          </ul>
        </section>
        <section>
          <h2>promise.race</h2>
          <blockquote style="width: 95%; font-size: smaller">
            &mdash; "Can we have a candy?"<br>
            &mdash; "The first who cleans his room gets a candy."
          </blockquote>
          <ul>
            <li>
              <div><pre class="bigger"><code class="language-javascript strict overlayrun" contenteditable>// kid1 promise
let cleanRoom1 = new Promise(function (resolve, reject) {
  setTimeout(
    () => resolve('kid 1 cleaned his room'),
    Math.random() * 2000
  )
})

// kid2 promise
let cleanRoom2 = new Promise(function (resolve, reject) {
  setTimeout(
    () => resolve('kid 2 cleaned his room'),
    Math.random() * 2000
  )
})

// first promise wins
Promise.race([
  cleanRoom1,
  cleanRoom2
]).then(res => console.log(res + ' first and gets the candy'));</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="Case study">
          <h2>Case study (1)</h2>
          <ul>
            <li>
              Let's throw an example together in Node, where we'll use
              <ul>
                <li>a generator to generate URL's</li>
                <li>promises to fetch and return the URL content (HTML)</li>
                <li>Node modules to parse and process the HTML to markup</li>
              </ul>
            </li>
            <li>
              Node modules needed (may also be globally installed):
              <div><pre class="bigger"><code class="language-javascript strict" data-caption="package.json" contenteditable>{
  ...
  "dependencies": {
    "hget": "^3.1.0",
    "marked": "^0.3.6",
    "marked-terminal": "^2.0.0",
    "request": "^2.79.0"
  }
}
</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Case study (2)</h2>
          <ul>
            <li>
              Requiring modules and creating the URL generator:
              <div><pre class="bigger"><code class="language-javascript strict" data-caption="script.js" contenteditable>// require modules
let request = require('request');
let hget = require('hget');
let marked = require('marked');
let MarkedTerminal = require('marked-terminal');

// define and create a generator for URL's
let urlGenerator = function*(){
  let urls = [
    'https://ikdoeict.be/',
    'https://ikdoeict.be/opleiding-ict/'
  ];
  while (urls.length) yield urls.shift();
}
let urlGen = urlGenerator();

...</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Case study (3)</h2>
          <ul>
            <li>
              Function that returns promise to request the URL:
              <div><pre class="bigger"><code class="language-javascript strict" data-caption="script.js (cont'd)" contenteditable>... 

// returns a promise to return the content found at an URL
let getNextPage = function () {
  let url = urlGen.next();
  return new Promise((resolve, reject) => {
    if (url.done) {
      reject('Done! No more pages');
      return;
    } 
    console.log(`Fetching next page at ${url.value}...`);
    request(url.value, (err, res, body) => {
      if (err) {
        reject(err); 
        return;
      }
      resolve(body);
    });
  });
};

...</code></pre></div>
            </li>
          </ul>
        </section>        
        <section data-toc-title="">
          <h2>Case study (4)</h2>
          <ul>
            <li>
              Recursive function to parse URL content delivered by promise:
              <div><pre class="bigger"><code class="language-javascript strict" data-caption="script.js (end)" contenteditable>... 

// displays and parses the content
let displayNextPage = function() {
  getNextPage()
    .then(html => hget(html, {
      markdown: true,
      root: 'div.main-content',
      ignore: '.at-subscribe,.mm-comments,.de-sidebar'
    }))
    .then(md => marked(md, {
      renderer: new MarkedTerminal()
    }))
    .then(txt => { 
      console.log(txt); 
      displayNextPage(); 
    })
    .catch(reason => console.error(reason));
}

// start recursive page call
displayNextPage();</code></pre></div>
            </li>
          </ul>
        </section>
        <section data-toc-title="">
          <h2>Case study (5)</h2>
          <ul>
            <li>
              Execute our script:
<div><pre class="bigger"><code class="donthighlight black">&gt; node script.js
</code></pre></div>
              <img src="img/02_es2015/final.png" alt="" class="border" style="max-width: 80%; margin: 0 auto; display: block; margin-top: 1rem" />
              <div class="demolink"><a href="demos/02_es2015/case-study.zip">case-study.zip</a></div>
            </li>
          </ul>
        </section>
      </section>

			<section data-index-title="">
				<section>
					<h2>Questions?</h2>
          <ul>
            <li>
              References:
              <ul>
                <li><a href="http://es6-features.org/">http://es6-features.org/</a></li>
                <li><a href="https://ponyfoo.com/">https://ponyfoo.com/</a></li>
                <li><a href="https://kangax.github.io/compat-table/es6/">https://kangax.github.io/compat-table/es6/</a></li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference</a></li>
              </ul>
            </li>
            <li>
              ES2015 tools:
              <ul>
                <li><a href="http://bevacqua.github.io/promisees/">http://bevacqua.github.io/promisees/</a></li>
                <li><a href="http://codepen.io/">http://codepen.io/</a></li>
                <li><a href="http://www.es6fiddle.net/">http://www.es6fiddle.net/</a></li>
                <li><a href="http://babeljs.io/">http://babeljs.io/</a></li>
                <li><a href="https://github.com/babel/babelify">https://github.com/babel/babelify</a></li>
              </ul>
            </li>
          </ul>
				</section>
			</section>

		</div>

		<!-- ikdoeict.be Link -->
		<a href="http://www.ikdoeict.be/" title="ikdoeict.be" id="ikdoeict">ikdoeict.be</a>

		<!-- Index Link -->
		<aside class="back">
	      <nav>
	        <p><a href="index.html">&larr; Back to index</a></p>
	      </nav>
		</aside>


		<!-- bottomleft links -->
		<ul id="extra">
		</ul>

	</div>

	<script src="library/jquery.min.js"></script>
	<script src="library/head.min.js"></script>
	<script src="library/reveal/reveal.min.js"></script>
  <script src="library/highlight/highlight.pack.js"></script>
	<script src="library/prefixfree.js"></script>
	<script src="library/css-snippets.js"></script>
	<script src="library/css-edit.js"></script>
	<script src="library/incrementable.js"></script>
	<script src="library/main.js"></script>

</body>
</html>
